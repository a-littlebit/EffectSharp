using EffectSharp.SourceGenerators;
using EffectSharp.SourceGenerators.Context;
using EffectSharp.SourceGenerators.Emitters;
using EffectSharp.SourceGenerators.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

[Generator]
public sealed class ReactiveModelGenerator : IIncrementalGenerator
{
    private static readonly IReactiveModelEmitter[] _emitters =
    {
        new ReactiveFieldEmitter(),
        new FunctionCommandEmitter(),
        new ComputedEmitter(),
        new ComputedListEmitter(),
        new WatchEmitter(),
        new InitializerEmitter()
    };

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        if (!Debugger.IsAttached)
        {
            // Debugger.Launch();
        }
#endif

        // Filter classes annotated with EffectSharp.SourceGenerators.ReactiveModelAttribute
        var models = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: "EffectSharp.SourceGenerators.ReactiveModelAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => (INamedTypeSymbol)ctx.TargetSymbol)
            .Where(static m => m is not null)
            .WithComparer(new TypeMemberAttributesComparer(new[]
            {
                "EffectSharp.SourceGenerators"
            }));

        var knownTypeRegistry = new KnownTypeRegistry();
        SymbolExtensions.RequireTypes(knownTypeRegistry);
        foreach (var emitter in _emitters)
        {
            emitter.RequireTypes(knownTypeRegistry);
        }

        var knownTypesProvider = knownTypeRegistry.Build(context.CompilationProvider);
        var pipeline = models.Combine(knownTypesProvider);

        context.RegisterSourceOutput(pipeline, static (spc, pair) =>
        {
            if (spc.CancellationToken.IsCancellationRequested)
                return;
            var (model, knownTypes) = pair;
            var modelContext = new ReactiveModelContext(spc, knownTypes, model);
            EmitModel(modelContext);
        });
    }

    private static void EmitModel(ReactiveModelContext context)
    {
        var model = context.ModelSymbol;
        var productionContext = context.ProductionContext;
        var cancellationToken = productionContext.CancellationToken;

        if (cancellationToken.IsCancellationRequested)
            return;
        var sw = new StringWriter();
        var iw = new IndentedTextWriter(sw, "    ");

        iw.WriteLine("// <auto-generated />");
        iw.WriteLine();
        iw.WriteLine("using EffectSharp;");
        iw.WriteLine();

        var ns = model.ContainingNamespace;
        if (!ns.IsGlobalNamespace)
        {
            iw.WriteLine("namespace " + ns.ToDisplayString());
            iw.WriteLine("{");
            iw.Indent++;
        }

        var version = typeof(ReactiveModelGenerator).Assembly.GetName().Version?.ToString() ?? "unknown";
        iw.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCode(\"EffectSharp.SourceGenerators.ReactiveModelGenerator\", \"{version}\")]");

        // Emit containing type wrappers if nested
        var containingTypes = new Stack<INamedTypeSymbol>();
        var ct = model.ContainingType;
        while (ct != null)
        {
            containingTypes.Push(ct);
            ct = ct.ContainingType;
        }

        foreach (var t in containingTypes)
        {
            iw.WriteLine(t.ComposeTypeHeader());
            // Constraints for outer types
            t.WriteTypeParameterConstraints(iw);
            iw.WriteLine("{");
            iw.Indent++;
        }

        // Compose base list for the model only when interfaces are not already implemented
        const string baseList = "IReactive, System.ComponentModel.INotifyPropertyChanging, System.ComponentModel.INotifyPropertyChanged";
        iw.WriteLine(model.ComposeTypeHeader(baseList));
        model.WriteTypeParameterConstraints(iw);
        iw.WriteLine("{");
        iw.Indent++;

        // Only emit events if not already declared on the type or any base type
        bool hasPropertyChanging = model.GetMemberInHierarchy<IEventSymbol>("PropertyChanging") != null;
        bool hasPropertyChanged = model.GetMemberInHierarchy<IEventSymbol>("PropertyChanged") != null;
        if (!hasPropertyChanging)
        {
            iw.WriteLine(
                "public event System.ComponentModel.PropertyChangingEventHandler PropertyChanging;");
        }
        if (!hasPropertyChanged)
        {
            iw.WriteLine(
                "public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;");
        }
        iw.WriteLine();

        if (cancellationToken.IsCancellationRequested)
            return;
        foreach (var emitter in _emitters)
        {
            emitter.Emit(context, iw);
            iw.WriteLine();
            if (cancellationToken.IsCancellationRequested)
                return;
        }

        iw.Indent--;
        iw.WriteLine("}");

        // Close containing types if any
        foreach (var _ in containingTypes)
        {
            iw.Indent--;
            iw.WriteLine("}");
        }

        if (!ns.IsGlobalNamespace)
        {
            iw.Indent--;
            iw.WriteLine("}");
        }

        // Use a unique hint name to avoid collisions across namespaces/nesting
        if (cancellationToken.IsCancellationRequested)
            return;
        var hintName = NameHelper.GetReactiveHintFileName(model);
        productionContext.AddSource(
            hintName,
            SourceText.From(sw.ToString(), Encoding.UTF8));
    }
}
