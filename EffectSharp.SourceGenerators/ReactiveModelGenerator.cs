using System;
using System.Collections.Immutable;
using System.CodeDom.Compiler;
using System.Diagnostics;
using System.IO;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using EffectSharp.SourceGenerators.Model;

namespace EffectSharp.SourceGenerators
{
    [Generator]
    public sealed partial class ReactiveModelGenerator : IIncrementalGenerator
    {
        private static readonly SymbolDisplayFormat FullName = SymbolDisplayFormat.FullyQualifiedFormat;

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
#if DEBUG
            if (!Debugger.IsAttached)
            {
                // Debugger.Launch();
            }
#endif
            var models = context.SyntaxProvider.ForAttributeWithMetadataName(
                "EffectSharp.SourceGenerators.ReactiveModelAttribute",
                static (node, _) => node is ClassDeclarationSyntax,
                static (ctx, token) => BuildModelSpec(ctx, token));

            context.RegisterSourceOutput(models, static (spc, result) =>
            {
                spc.CancellationToken.ThrowIfCancellationRequested();

                foreach (var diag in result.Diagnostics)
                {
                    spc.ReportDiagnostic(diag);
                }

                if (!result.HasSpec)
                    return;

                EmitSource(spc, result.Spec);
            });
        }

        private static ModelSpecResult BuildModelSpec(GeneratorAttributeSyntaxContext ctx, System.Threading.CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var modelSymbol = ctx.TargetSymbol as INamedTypeSymbol;
            if (modelSymbol == null)
                return ModelSpecResult.Empty;

            var compilation = ctx.SemanticModel.Compilation;
            var diagnostics = ImmutableArray.CreateBuilder<Diagnostic>();

            cancellationToken.ThrowIfCancellationRequested();

            var typeSpec = CreateTypeSpec(modelSymbol, compilation);
            cancellationToken.ThrowIfCancellationRequested();

            var reactiveFields = BuildReactiveFields(modelSymbol, compilation);
            cancellationToken.ThrowIfCancellationRequested();

            var computed = BuildComputed(modelSymbol, diagnostics);
            cancellationToken.ThrowIfCancellationRequested();

            var computedLists = BuildComputedLists(modelSymbol, compilation, diagnostics);
            cancellationToken.ThrowIfCancellationRequested();

            var functionCommands = BuildFunctionCommands(modelSymbol, compilation, diagnostics);
            cancellationToken.ThrowIfCancellationRequested();

            var watches = BuildWatches(modelSymbol, diagnostics);

            var deepTracks = BuildDeepTracks(modelSymbol, compilation, diagnostics);

            var spec = new ModelSpec(
                typeSpec,
                reactiveFields,
                computed,
                computedLists,
                functionCommands,
                watches,
                deepTracks);

            return new ModelSpecResult(spec, diagnostics.ToImmutable());
        }

        private static void EmitSource(SourceProductionContext context, ModelSpec spec)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            using var sw = new StringWriter();
            using var iw = new IndentedTextWriter(sw, "    ");

            iw.WriteLine("// <auto-generated />");
            iw.WriteLine();
            iw.WriteLine("using System;");
            iw.WriteLine("using System.Collections.Generic;");
            iw.WriteLine("using System.ComponentModel;");
            iw.WriteLine("using System.Linq;");
            iw.WriteLine("using System.Text;");
            iw.WriteLine("using System.Threading;");
            iw.WriteLine("using System.Threading.Tasks;");
            iw.WriteLine("using EffectSharp;");
            iw.WriteLine();

            if (!string.IsNullOrEmpty(spec.Type.Namespace))
            {
                iw.WriteLine("namespace " + spec.Type.Namespace);
                iw.WriteLine("{");
                iw.Indent++;
            }

            foreach (var ct in spec.Type.ContainingTypes)
            {
                iw.WriteLine(ct.Header);
                foreach (var constraint in ct.Constraints)
                {
                    iw.WriteLine(constraint);
                }
                iw.WriteLine("{");
                iw.Indent++;
            }

            var version = typeof(ReactiveModelGenerator).Assembly.GetName().Version?.ToString() ?? "unknown";
            iw.WriteLine("[global::System.CodeDom.Compiler.GeneratedCode(\"EffectSharp.SourceGenerators\", \"" + version + "\")]");
            iw.WriteLine(spec.Type.Header);
            foreach (var constraint in spec.Type.Constraints)
            {
                iw.WriteLine(constraint);
            }
            iw.WriteLine("{");
            iw.Indent++;

            EmitEvents(spec, iw);
            EmitReactiveFields(spec, iw);
            EmitComputed(spec, iw);
            EmitComputedLists(spec, iw);
            EmitFunctionCommands(spec, iw);
            EmitWatches(spec, iw);
            EmitTrackDeep(spec, iw);
            EmitLifecycle(spec, iw);

            iw.Indent--;
            iw.WriteLine("}");

            for (int i = spec.Type.ContainingTypes.Length - 1; i >= 0; i--)
            {
                iw.Indent--;
                iw.WriteLine("}");
            }

            if (!string.IsNullOrEmpty(spec.Type.Namespace))
            {
                iw.Indent--;
                iw.WriteLine("}");
            }

            context.AddSource(spec.Type.HintName, sw.ToString());
        }

        private static void EmitEvents(ModelSpec spec, IndentedTextWriter iw)
        {
            if (spec.Type.EmitPropertyChangingEvent)
            {
                iw.WriteLine("public event System.ComponentModel.PropertyChangingEventHandler PropertyChanging;");
            }
            if (spec.Type.EmitPropertyChangedEvent)
            {
                iw.WriteLine("public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;");
            }
            if (spec.Type.EmitPropertyChangingEvent || spec.Type.EmitPropertyChangedEvent)
            {
                iw.WriteLine();
            }
        }

        private static void EmitLifecycle(ModelSpec spec, IndentedTextWriter iw)
        {
            iw.WriteLine("public void InitializeReactiveModel()");
            iw.WriteLine("{");
            iw.Indent++;

            EmitComputedInitializers(spec, iw);
            EmitComputedListInitializers(spec, iw);
            EmitFunctionCommandInitializers(spec, iw);
            EmitWatchInitializers(spec, iw);

            iw.Indent--;
            iw.WriteLine("}");
            iw.WriteLine();

            iw.WriteLine("public void DisposeReactiveModel()");
            iw.WriteLine("{");
            iw.Indent++;

            EmitComputedDisposers(spec, iw);
            EmitComputedListDisposers(spec, iw);
            EmitFunctionCommandDisposers(spec, iw);
            EmitWatchDisposers(spec, iw);

            iw.Indent--;
            iw.WriteLine("}");
        }
    }
}
